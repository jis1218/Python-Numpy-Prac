# Python numpy 연습

##### numpy로 배열을 선언할 때와 그냥 선언할 때 연산을 하면 다르게 나온다.
```python
import numpy as np
if __name__ == '__main__':
    
    a = np.array([1, 2, 3])
    b = np.array([4, 5, 6])
    print(a+b) #[5 7 9]
    
    c = [1, 2, 3]
    d = [4, 5, 6]
    print(c+d) #[1, 2, 3, 4, 5, 6]
    
    pass
```

##### Numpy로는 배열도 계산할 수 있는데
```python

    e = np.array([[1, 2], [1, 2]])
    f = np.array([[3, 4], [3, 4]])
    print(e+f)
```
##### 이걸 계산하게 되면 벡터의 합이 그대로 나온다.
##### 하지만 곱을 계산하면
```python
    e = np.array([[1, 2], [1, 2]])
    f = np.array([[3, 4], [3, 4]])
    print(e*f)
```

##### 우리가 배운 행렬의 곱이 아닌 원소별 곱이 나온다.
##### 즉 [[9,12], [9,12]]가 나오는게 아닌 [[3,8], [3,8]]이 나오게 된다.

##### 브로드캐스트라는 것도 있는데
```python
    e = np.array([[1, 2], [1, 2]])
    
    print(e*10)
```
##### 이걸 계산하게 되면 [[10, 20], [10, 20]]이 나오게 된다. 10은 1X1 배열이지만 2X2 배열로 형상변환된 후 각 원소를 스칼라곱으로 계산한 값이 나오게 된다. (element-wise product)